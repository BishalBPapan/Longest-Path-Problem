# -*- coding: utf-8 -*-
"""LongestPath-DynamicProgramming.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1tLONWZ3H9QOhLY0w8kp6XWJl9SAeozi4
"""

# from google.colab import drive
# drive.mount('/content/drive')

import numpy as np
import pandas as pd
INF = 100000

"""
0  	39  22  200
39   0  -43  -500
22  -43   0  -500
200  -500  -500   0
"""

FILE_NAME = "/content/drive/MyDrive/Mahim-Profile-Things/Adj_matrix/jb13_dist.txt"


# FILE_NAME_LIST = [
#     "co04", "five", "grid04", "jb13", "lau15", "sh07", "sp11", "uk12", "wg22", "gr17"
# ]



distance_matrix = np.loadtxt(FILE_NAME)
print(distance_matrix)
print(distance_matrix.shape)

"""## Read data"""



## https://stackoverflow.com/questions/1482308/how-to-get-all-subsets-of-a-set-powerset
# def powerset(s):
#     x = len(s)
#     masks = [1 << i for i in range(x)]
#     for i in range(1 << x):
#         yield [ss for mask, ss in zip(masks, s) if i & mask]

def generate_subsets_above_len(maxsize, least_len=0, max_len=2, exact_length=2):
    x = maxsize + 1 # len(s)
    s = np.arange(0, x)
    list_set = []
    for i in range(1, 1 << x):
        list_temp = [s[j] for j in range(x) if (i & (1 << j))]
        if (len(list_temp) == exact_length):
            list_set.append(list_temp)

    return list_set



power_set = generate_subsets_above_len(maxsize=3, exact_length=3)

# power_set = generate_subsets_above_len(s=[0, 1, 2, 3]) 
## [[0, 1], [0, 2], [1, 2], [0, 1, 2], [0, 3], [1, 3], [0, 1, 3], [2, 3], [0, 2, 3], [1, 2, 3], [0, 1, 2, 3]]
print(power_set)

"""## DP formulation"""

def print_dictionary(dictionary):
    for key in dictionary:
        print("Key: ", key, ", Value: ", dictionary[key])


def return_path_with_cost(OPT, source=0):
    best_weight = -1
    best_list = None

    for key in OPT: ## key -> (vertex, subset)
        if source != key[0]:
            continue
        (weight_path, list_of_vertices) = OPT[key]
        if weight_path > best_weight:
            best_weight = weight_path
            best_list = list_of_vertices

    best_list.insert(0, source)
    new_list = []
    for val in best_list:
        if val == -1:
            break
        new_list.append(val)
    return best_weight, new_list

def compute_LP_DP(distance_matrix, NULL_VERTEX=-1, INFINITY=10000):
    source = 0 ## Assume source at 0 always
    OPT = {} ## Double dictionary key: pair of <source, {subset}> ||| value: (cost, kept_vertex)
    for outer_vertex in range(len(distance_matrix)): ## Single edge initialization. [Base Case]
        for inner_vertex in range(len(distance_matrix)):
            if inner_vertex == outer_vertex: ## Ignore for same
                continue
            cost = distance_matrix[outer_vertex][inner_vertex]
            list_1 = []
            if cost > 0: ## Only now CHOOSE this EDGE.
                list_1.append(inner_vertex)
                OPT[outer_vertex, tuple({inner_vertex})] = (cost, list_1)
            else: ## DO NOT choose this edge.
                list_1.append(NULL_VERTEX)
                OPT[outer_vertex, tuple({inner_vertex})] = (0, list_1)

    for num_subset_length in range(2, len(distance_matrix)): ## Multiple edge condition. [Assume > 2 vertices !!]
        subsets_all = generate_subsets_above_len(maxsize=len(distance_matrix)-1, exact_length=num_subset_length) ## generate subset here
        for src_vertex in range(len(distance_matrix)):
            for subset in subsets_all:
                if src_vertex in subset: ## loop over all subsets for THIS length
                    continue
                max_cost = -INFINITY
                best_neighbor = NULL_VERTEX
                best_list = []
                for neighbor in subset: ## loop over THIS subset for EACH NEIGHBOR
                    subset_without_inner_vertex = tuple(filter(lambda x: x!=neighbor, subset))
                    current_cost_neighbor = distance_matrix[src_vertex][neighbor] + OPT[neighbor, subset_without_inner_vertex][0] ## first-element is cost, second is 
                    if current_cost_neighbor > max_cost: ## update for THIS neighbor
                        max_cost = current_cost_neighbor
                        best_neighbor = neighbor
                        best_list = OPT[neighbor, subset_without_inner_vertex][1] ## list of vertices

                update_list_flag = True
                if max_cost < 0: ## DON'T take anyone from THIS subset.
                    max_cost = 0
                    update_list_flag = False
                new_list = best_list.copy() ## keep a copy
                if update_list_flag == True:
                    new_list.insert(0, best_neighbor) ## add to head
                OPT[src_vertex, tuple(subset)] = (max_cost, new_list) ## for now first-elemnt cost, second is neighbor/vertex_taken
    return OPT ## Finally, Return




# all_subsets = generate_subsets_above_len(maxsize=len(distance_matrix))
OPT = compute_LP_DP(distance_matrix=distance_matrix)
best_weight, best_list = return_path_with_cost(OPT, source=0)
print(f"Best Weight = {best_weight}, Best Path = {best_list}")
# print_dictionary(OPT)

# def appendAndReturn_DataframeRes(df_old, metrics_list):
#     a_series = pd.Series(metrics_list, index=df_old.columns)
#     df_old = df_old.append(a_series, ignore_index=True)
#     return df_old

# columns = ["File", "Shape", "Src", "Best-Wt", "Best-Path"]
# df = pd.DataFrame(columns=columns)
# print(df)

# df = appendAndReturn_DataframeRes(df_old=df, metrics_list=["Ca", (5,5), 0, 123, [1,2,3]])
# print(df)